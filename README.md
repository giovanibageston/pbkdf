# Go PBKDF1 and PBKDF2 Implementation
[Wikipedia](https://en.wikipedia.org/wiki/PBKDF2)

This is a **PBKDF1** and **PBKDF2** implementation in **Go**.
It relies on the *crypto* package for the *hash functions* and *random number generation*.

The algorithms are implemented following *[RFC8018](https://datatracker.ietf.org/doc/html/rfc8018)*.

## License
This code is supplied under the MIT license, see the LICENSE file for more details.

## Basic Usage
You can call either EncodePassword or EncodePasswordPBKDF1 or EncodePasswordPBKDF2 to encode a password,
if you're calling EncodePassword you will need to supply a **kdf** function with the PBKDF signature,
the PBKDF1 and PBKDF2 satisfy this signature and are supplied as part of the library.

If you wish to verify a password you can call either VerifyPassword or VerifyPasswordPBKDF1 or VerifyPasswordPBKDF2,
to verify the password you must supply the same hash and kdf that were supplied to the encode method.

## Main Functions
The functions for PBKDF1 and PBKDF2 have the PBKDF signature as follows:
> PBKDF(hash, P, S, dkLen) -> DK, error

### Parameters
The parameters for both functions are the same as follows:
- **hash**: The *PRF*(pseudo-random function) to be used. It must be a hash function compatible with the *crypto package*. (*type crypto.Hash*)
- **P**: The password we want to derive the key from. (*type []byte*)
- **S**: The salt to be used. (*type []byte*)
- **c**: The number of iterations. (*type int64*)
- **dkLen**: The length of the derived key. (*type int64*)
### Return Values
The return values are the same for both functions as follows:
- **DK**: The derived key. (*type []byte*)
- **error**: An error if any. (*type error*)

## Usage
Although it's possbile to use the one the functions(**PBKDF1** and **PBKDF2**) by themselves the library provides helper functions to use the algorithms in a more convenient way.

### Encoding
The library defines 3 functions to encode a password:
> EncodePassword(hash, password, saltLength, iterationCount, keyLength, kdf) -> string, error

> EncodePasswordPBKDF1(hash, password, saltLength, iterationCount, keyLength) -> string, error

> EncodePasswordPBKDF2(hash, password, saltLength, iterationCount, keyLength) -> string, error

#### EncodePassword
This function generates a random salt of of saltLength bytes, converts the password from a string to a []byte slice and calls the supplied **kdf** function.
It then passes the salt, the iteration count and the derived key to the function **GeneratePasswordString**
and returns the result.

#### EncodePasswordPBKDF1
The same as calling EncondePassword with the **kdf** parameter set to **PBKDF1**

#### EncodePassword
The same as calling EncondePassword with the **kdf** parameter set to **PBKDF2**

## Verification
The library defines 3 functions to verify a password:
> VerifyPassword(hash, password, encodedPassword, kdf) -> bool, error
 
> VerifyPasswordPBKDF1(hash, password, encodedPassword) -> bool, error

> VerifyPasswordPBKDF2(hash, password, encodedPassword) -> bool, error

#### VerifyPassword
This function decodes the supplied **encodedPassword** using the function **GetPasswordParametersFromString**.
It then calls the supplied **kdf** function with the parameters from the decoded password and compare the supplied key with the derived key.

#### VerifyPasswordPBKDF1
The same as calling VerifyPassword with the **kdf** parameter set to **PBKDF1**

#### VerifyPasswordPBKDF2
The same as calling VerifyPassword with the **kdf** parameter set to **PBKDF2**

### Utility Functions

#### GeneratePasswordString
This function takes the salt(as a []byte sloce), the iteration count and the derived key(alo as a []byte slice) and returns a string in the format:
salt:iterationCount:derivedKey where:
- **salt**: The salt encoded in base64
- **iterationCount**: The iteration count in decimal format
- **derivedKey**: The derived key encoded in base64

#### GetPasswordParametersFromString
This function takes a string in the format generated by **GeneratePasswordString** and returns the salt(as a []byte slice), the iteration count and the derived key(as a []byte slice).

#### GenerateRandomSequence
This function generates a random sequence of bytes of the specified length, it uses cryto/rand to generate the random sequence.

#### GenerateRandomByte
This function takes a min and max value and returns a random byte(unsigned 8 bit integer) between the two values(inclusive), it uses cryto/rand to generate the random byte.

#### GenerateRandomInt64
This function takes a min and max value and returns a random int64(signed 64 bit integer) between the two values(inclusive), it uses cryto/rand to generate the random int64.

#### GenerateRandomPassword
This function takes a min and max value and returns a random password of length between min and max(inclusive), it uses cryto/rand to generate the random password.
The password will only contain letters, numbers and the following symbols:!@#$%&*()-_+=[]{}^~?/:;<>.,

#### GenerateRandomPasswordFromRunes
This function takes a min and max value and a []rune slice. It returns a random password of length between min and max(inclusive) composed of random runes from the supplied slice. It uses cryto/rand to generate the random password.

#### GetRandomRune
This function takes a []rune slice and returns a random rune from the slice. It uses cryto/rand to generate the random rune.

#### ConvertUnsignedIntegerToByteSlice
This function converts an uint64 to a []byte slice

#### ConvertSliceToUnsignedInteger
This function converts a []byte slice to an uint64
